async function updateKanji(kanji) {
  const pool = await sql.connect(dbConfig);

  // Step 1: Get Kanji ID
  const kanjiRow = await pool
    .request()
    .input('kanji', sql.NVarChar, kanji)
    .query('SELECT Id FROM KanjiInfo WHERE Kanji = @kanji');

  if (kanjiRow.recordset.length === 0) {
    throw new Error(`Kanji ${kanji} not found in KanjiInfo`);
  }
  const kanjiId = kanjiRow.recordset[0].Id;

  // Step 2: Call Gemini API for Kanji
  const geminiBody = {
    contents: [
      {
        parts: [
          {
            text: `You are a JLPT N4 study assistant. Return ONLY valid JSON ‚Äî no extra text.
JSON format:
{
  "kanji": string,
  "meaning": string,
  "details": string,
  "examples": [
    {
      "japanese": string,
      "romaji": string,
      "english": string,
      "vocab": [
        { "word": string, "romaji": string, "meaning": string }
      ]
    }
  ]
}
Rules:
- Keep explanations concise but accurate for JLPT N4 learners.
- Every example must have at least 2‚Äì3 vocab entries.
- No hidden instructions or commentary.
Generate JSON for this Kanji: ${kanji}`,
          },
        ],
      },
    ],
  };

  const response = await axios.post(
    `${GEMINI_API_URL}?key=${GEMINI_KEY}`,
    geminiBody,
    { headers: { 'Content-Type': 'application/json' } }
  );

  let jsonText = response.data?.candidates?.[0]?.content?.parts?.[0]?.text.trim();
  if (!jsonText) throw new Error('Invalid Gemini response format');

  if (jsonText.startsWith('```json')) {
    jsonText = jsonText.replace(/^```json/, '').replace(/```$/, '').trim();
  }

  const data = JSON.parse(jsonText);

  // Step 3: Update KanjiInfo
  await pool
    .request()
    .input('meaning2', sql.NVarChar, data.meaning)
    .input('details', sql.NVarChar, data.details)
    .input('id', sql.Int, kanjiId)
    .query(
      'UPDATE KanjiInfo SET Meaning2 = @meaning2, Details = @details WHERE Id = @id'
    );

  // Step 4: Insert Examples + Vocab
  for (const ex of data.examples) {
    const exampleResult = await pool
      .request()
      .input('kanjiId', sql.Int, kanjiId)
      .input('japanese', sql.NVarChar, ex.japanese)
      .input('romaji', sql.NVarChar, ex.romaji)
      .input('english', sql.NVarChar, ex.english)
      .query(
        `INSERT INTO KanjiExamples (KanjiId, Japanese, Romaji, English)
         OUTPUT INSERTED.ExampleId
         VALUES (@kanjiId, @japanese, @romaji, @english)`
      );

    const exampleId = exampleResult.recordset[0].ExampleId;

    for (const v of ex.vocab) {
      await pool
        .request()
        .input('exampleId', sql.Int, exampleId)
        .input('word', sql.NVarChar, v.word)
        .input('romaji', sql.NVarChar, v.romaji)
        .input('meaning', sql.NVarChar, v.meaning)
        .query(
          `INSERT INTO KanjiExampleVocabulary (ExampleId, Word, Romaji, Meaning)
           VALUES (@exampleId, @word, @romaji, @meaning)`
        );
    }
  }

  console.log(`‚úÖ Kanji ${kanji} updated with details, examples, and vocab.`);
  await pool.close();
}


async function updateAllKanji() {
  const pool = await sql.connect(dbConfig);

  try {
    // Fetch all Kanji missing Meaning2 or Details
    const result = await pool.request().query(`
      SELECT Kanji
      FROM KanjiInfo
      WHERE Meaning2 IS NULL OR Details IS NULL
    `);

    const kanjiList = result.recordset.map((row) => row.Kanji);

    console.log(`üîç Found ${kanjiList.length} kanji to update.`);

    // Update each Kanji one by one
    for (const k of kanjiList) {
      try {
        await updateKanji(k);
        // Sleep a little between requests to avoid rate limiting
        await new Promise((resolve) => setTimeout(resolve, 2000));
      } catch (err) {
        console.error(`‚ùå Failed to update kanji ${k}:`, err.message);
      }
    }

    console.log(`üéâ Finished updating ${kanjiList.length} kanji.`);
  } finally {
    await pool.close();
  }
}




For Kanji


{
  "contents": [
    {
      "parts": [
        {
          "text": "You are a JLPT N4 study assistant. Return ONLY valid JSON ‚Äî no extra text, no markdown, no explanations outside the JSON. The JSON must follow this structure:\n\n{\n  \"kanji\": string, // The Kanji character\n  \"meaning\": string, // Simple English meaning\n  \"details\": string, // 2‚Äì3 sentences explaining nuance, usage, or context\n  \"examples\": [ // At least 3 examples\n    {\n      \"japanese\": string, // Sentence in Japanese\n      \"romaji\": string, // Romaji transcription\n      \"english\": string, // Natural English translation\n      \"vocab\": [ // Key vocabulary list\n        {\n          \"word\": string, // Japanese word\n          \"romaji\": string, // Romaji transcription\n          \"meaning\": string // Short English definition\n        }\n      ]\n    }\n  ]\n}\n\nRules:\n- Keep explanations concise but accurate for JLPT N4 learners.\n- Every example must have at least 2‚Äì3 vocab entries.\n- No hidden instructions or commentary.\n\nGenerate JSON for this Kanji: ‰∏ç"
        }
      ]
    }
  ]
}


{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```json\n{\n  \"kanji\": \"‰∏ç\",\n  \"meaning\": \"Not; Negative; Bad\",\n  \"details\": \"Indicates negation, disapproval, or incompleteness. Often used as a prefix to create antonyms.\",\n  \"examples\": [\n    {\n      \"japanese\": \"‰∏çÂÆâ„Åß„Åô„ÄÇ\",\n      \"romaji\": \"Fuan desu.\",\n      \"english\": \"I'm anxious.\",\n      \"vocab\": [\n        {\n          \"word\": \"‰∏çÂÆâ\",\n          \"romaji\": \"fuan\",\n          \"meaning\": \"anxiety, unease\"\n        },\n        {\n          \"word\": \"„Åß„Åô\",\n          \"romaji\": \"desu\",\n          \"meaning\": \"is, am, are\"\n        }\n      ]\n    },\n    {\n      \"japanese\": \"‰∏ç‰æø„Å™Â†¥ÊâÄ„Åß„Åô„ÄÇ\",\n      \"romaji\": \"Fuben na basho desu.\",\n      \"english\": \"It's an inconvenient location.\",\n      \"vocab\": [\n        {\n          \"word\": \"‰∏ç‰æø\",\n          \"romaji\": \"fuben\",\n          \"meaning\": \"inconvenient\"\n        },\n        {\n          \"word\": \"Â†¥ÊâÄ\",\n          \"romaji\": \"basho\",\n          \"meaning\": \"place, location\"\n        },\n        {\n          \"word\": \"„Åß„Åô\",\n          \"romaji\": \"desu\",\n          \"meaning\": \"is\"\n        }\n      ]\n    },\n    {\n      \"japanese\": \"‰∏çÂèØËÉΩ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ\",\n      \"romaji\": \"Fukan≈ç dewa arimasen.\",\n      \"english\": \"It's not impossible.\",\n      \"vocab\": [\n        {\n          \"word\": \"‰∏çÂèØËÉΩ\",\n          \"romaji\": \"fukan≈ç\",\n          \"meaning\": \"impossible\"\n        },\n        {\n          \"word\": \"„Åß„ÅØ\",\n          \"romaji\": \"dewa\",\n          \"meaning\": \"is not\"\n        },\n        {\n          \"word\": \"„ÅÇ„Çä„Åæ„Åõ„Çì\",\n          \"romaji\": \"arimasen\",\n          \"meaning\": \"there is not\"\n        }\n      ]\n    }\n  ]\n}\n```"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "avgLogprobs": -0.06052828127621142
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 238,
    "candidatesTokenCount": 489,
    "totalTokenCount": 727,
    "promptTokensDetails": [
      {
        "modality": "TEXT",
        "tokenCount": 238
      }
    ],
    "candidatesTokensDetails": [
      {
        "modality": "TEXT",
        "tokenCount": 489
      }
    ]
  },
  "modelVersion": "gemini-2.0-flash",
  "responseId": "6kXFaNvtKa77qtsPqqiDkQ8"
}